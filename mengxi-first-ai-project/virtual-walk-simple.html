<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Walk - ç®€å•ç‰ˆ</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        /* ä¿æŒåŸæœ‰æ ·å¼ä¸å˜ */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Microsoft Yahei', Arial, sans-serif; }
        body { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; min-height: 100vh; }
        #header { background: rgba(255,255,255,0.1); padding: 1.5rem; text-align: center; backdrop-filter: blur(10px); box-shadow: 0 2px 20px rgba(0,0,0,0.1); margin-bottom: 20px; }
        #header h1 { font-size: 2.2rem; margin-bottom: 0.5rem; color: #2ecc71; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        #statusBar { background: rgba(255,255,255,0.1); padding: 1rem; margin: 0 20px 20px; border-radius: 12px; backdrop-filter: blur(10px); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
        #gameArea { display: grid; grid-template-columns: 1fr 2fr; gap: 20px; padding: 0 20px; margin-bottom: 20px; }
        #cameraSection { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 12px; backdrop-filter: blur(10px); }
        #videoElement, #outputCanvas { width: 100%; max-width: 320px; border-radius: 8px; display: block; margin: 0 auto 10px; }
        #currentGesture { font-size: 18px; font-weight: bold; color: #00ff88; text-align: center; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; margin-bottom: 10px; }
        #actionLog { font-size: 14px; color: #fff; text-align: center; background: rgba(0,0,0,0.2); padding: 5px; border-radius: 5px; margin-bottom: 10px; }
        #debugLog { font-size: 12px; color: #fff; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; max-height: 100px; overflow-y: auto; }
        #mapSection { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 12px; backdrop-filter: blur(10px); }
        #map { height: 500px; border-radius: 8px; }
        #controlPanel { background: rgba(255,255,255,0.1); padding: 1.2rem; margin: 0 20px; border-radius: 12px; backdrop-filter: blur(10px); display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }
        .control-btn { padding: 12px 24px; border: none; border-radius: 8px; color: white; font-size: 15px; cursor: pointer; transition: all 0.3s ease; font-weight: 600; min-width: 120px; }
        .camera-btn { background: rgba(46,204,113,0.8); }
        .camera-btn:hover { background: rgba(46,204,113,1); transform: translateY(-2px); }
        .map-btn { background: rgba(52,152,219,0.8); }
        .map-btn:hover { background: rgba(52,152,219,1); transform: translateY(-2px); }
        .leaflet-control-attribution { background: rgba(0,0,0,0.6) !important; color: white !important; font-size: 10px !important; }
        @media (max-width: 768px) { #gameArea { grid-template-columns: 1fr; } #statusBar { flex-direction: column; text-align: center; } #map { height: 400px; } }
    </style>
</head>
<body>
    <div id="header">
        <h1>ğŸ–ï¸ Virtual Walk - ç®€å•ç‰ˆ</h1>
        <p>OpenStreetMap optimized gesture control with debug mode</p>
    </div>

    <div id="statusBar">
        <div id="gestureStatus">ç­‰å¾…å¯åŠ¨æ‘„åƒå¤´...</div>
        <div id="mapStatus">åœ°å›¾åŠ è½½ä¸­...</div>
    </div>

    <div id="gameArea">
        <div id="cameraSection">
            <video id="videoElement" width="320" height="240" autoplay muted playsinline style="display: none;"></video>
            <canvas id="outputCanvas" width="320" height="240"></canvas>
            <div id="currentGesture">æ— æ‰‹åŠ¿</div>
            <div id="actionLog">ç­‰å¾…æ‰‹åŠ¿è¾“å…¥...</div>
            <div id="debugLog">è°ƒè¯•ä¿¡æ¯å°†åœ¨æ­¤æ˜¾ç¤º...</div>
        </div>

        <div id="mapSection">
            <div id="map"></div>
        </div>
    </div>

    <div id="controlPanel">
        <button class="control-btn camera-btn" id="startCamera">å¯åŠ¨æ‘„åƒå¤´</button>
        <button class="control-btn map-btn" id="resetMap">é‡ç½®åœ°å›¾</button>
        <button class="control-btn map-btn" id="toggleLayer">åˆ‡æ¢å›¾å±‚</button>
    </div>

    <!-- Gesture Documentation Panel -->
    <div style="max-width: 1200px; margin: 2rem auto; padding: 0 20px;">
        <div class="project-card">
            <h3>ğŸ¤² æ‰‹åŠ¿æ“ä½œè¯´æ˜</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin: 1rem 0;">
                <div style="padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <strong>ğŸ‘ˆ å·¦æŒ¥æ‰‹</strong>
                    <p>åˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªåœ°æ ‡ä½ç½®</p>
                </div>
                <div style="padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <strong>ğŸ‘‰ å³æŒ¥æ‰‹</strong>
                    <p>åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªåœ°æ ‡ä½ç½®</p>
                </div>
                <div style="padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <strong>ğŸ‘‡ æ‰‹æŒ‡æŒ‡å‘</strong>
                    <p>å‘æŒ‡å‘æ–¹å‘å¹³ç§»åœ°å›¾</p>
                </div>
                <div style="padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <strong>ğŸ‘ åŒæ‰‹å¼ å¼€</strong>
                    <p>æ”¾å¤§åœ°å›¾</p>
                </div>
                <div style="padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <strong>ğŸ¤ åŒæ‰‹æåˆ</strong>
                    <p>ç¼©å°åœ°å›¾</p>
                </div>
                <div style="padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <strong>ğŸ‘ æ‹æ‰‹</strong>
                    <p>éšæœºè·³è½¬åˆ°ä¸‹ä¸€ä¸ªåœ°æ ‡</p>
                </div>
                <div style="padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <strong>ğŸ‘‹ æŒ¥æ‰‹</strong>
                    <p>åˆ‡æ¢åœ°å›¾å›¾å±‚</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

    <script>
        function debugLog(msg) {
            const logElement = document.getElementById('debugLog');
            const now = new Date().toLocaleTimeString();
            logElement.innerHTML += `[${now}] ${msg}<br>`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        let map;
        let gestureController;

        // é™ä½é˜ˆå€¼ä»¥æé«˜æ£€æµ‹çµæ•åº¦
        class OSMGestureController {
            constructor() {
                this.interaction_mode = "exploration";
                this.map = null;
                this.currentZoom = 16;
                this.landmarks = [
                    { lat: 48.8566, lng: 2.3522, name: "å·´é»åŸƒè²å°”é“å¡”" },
                    { lat: 48.8738, lng: 2.2950, name: "å·´é»å‡¯æ—‹é—¨" },
                    { lat: 40.4156, lng: -3.7135, name: "é©¬å¾·é‡Œè¥¿ç­ç‰™å¹¿åœº" },
                    { lat: 45.4642, lng: 9.1900, name: "ç±³å…°å¤§æ•™å ‚" },
                    { lat: 41.9028, lng: 12.4964, name: "ç½—é©¬æ–—å…½åœº" },
                    { lat: 51.5007, lng: -0.1246, name: "ä¼¦æ•¦å¤§æœ¬é’Ÿ" },
                    { lat: 52.3676, lng: 4.9041, name: "é˜¿å§†æ–¯ç‰¹ä¸¹è¿æ²³" },
                    { lat: 41.4033, lng: 2.1741, name: "å·´å¡ç½—é‚£åœ£å®¶å ‚" }
                ];
                this.currentLandmarkIndex = 0;
            }

            setMap(map) { this.map = map; }

            detectPointingGesture(landmarks) {
                const rightWrist = landmarks[16];
                const rightShoulder = landmarks[12];
                const rightElbow = landmarks[14];

                // é™ä½æ£€æµ‹é˜ˆå€¼
                const armStraight = Math.abs(rightWrist.y - rightShoulder.y) > 0.1 &&
                                   Math.abs(rightElbow.y - (rightShoulder.y + rightWrist.y) / 2) < 0.08;

                debugLog(`Pointing detect: ${armStraight}`);
                return armStraight;
            }

            getPointingDirection(landmarks) {
                const rightWrist = landmarks[16];
                const rightShoulder = landmarks[12];
                const deltaX = rightWrist.x - rightShoulder.x;
                const deltaY = rightWrist.y - rightShoulder.y;

                return Math.abs(deltaX) > Math.abs(deltaY) ? (deltaX > 0 ? "right" : "left") : (deltaY > 0 ? "down" : "up");
            }

            pan_map_toward_direction(direction) {
                if (!this.map) return;
                const currentCenter = this.map.getCenter();
                const moveDistance = 0.0008;
                let newLat = currentCenter.lat;
                let newLng = currentCenter.lng;

                switch (direction) {
                    case "up": newLat += moveDistance; break;
                    case "down": newLat -= moveDistance; break;
                    case "left": newLng -= moveDistance; break;
                    case "right": newLng += moveDistance; break;
                }

                this.map.setView([newLat, newLng], this.currentZoom, { animate: true, duration: 0.5 });
                debugLog(`Map pan ${direction}`);
            }

            detect_spread_hands(landmarks) {
                const leftWrist = landmarks[15];
                const rightWrist = landmarks[16];
                const distance = Math.sqrt(Math.pow(rightWrist.x - leftWrist.x, 2) + Math.pow(rightWrist.y - leftWrist.y, 2));

                debugLog(`Spread hands: ${distance}`);
                return distance > 0.25; // é™ä½è·ç¦»é˜ˆå€¼
            }

            detect_pinch_hands(landmarks) {
                const leftWrist = landmarks[15];
                const rightWrist = landmarks[16];
                const distance = Math.sqrt(Math.pow(rightWrist.x - leftWrist.x, 2) + Math.pow(rightWrist.y - leftWrist.y, 2));

                debugLog(`Pinch hands: ${distance}`);
                return distance < 0.15; // é™ä½è·ç¦»é˜ˆå€¼
            }

            zoom_in() { this.currentZoom = Math.min(19, this.currentZoom + 1); this.map.setZoom(this.currentZoom); debugLog(`Zoom in: ${this.currentZoom}`); }
            zoom_out() { this.currentZoom = Math.max(8, this.currentZoom - 1); this.map.setZoom(this.currentZoom); debugLog(`Zoom out: ${this.currentZoom}`); }

            detect_clap_gesture(landmarks) {
                const leftWrist = landmarks[15];
                const rightWrist = landmarks[16];
                const distance = Math.sqrt(Math.pow(rightWrist.x - leftWrist.x, 2) + Math.pow(rightWrist.y - leftWrist.y, 2));

                debugLog(`Clap detect: ${distance}`);
                return distance < 0.1; // é™ä½é˜ˆå€¼
            }

            jump_to_next_landmark() {
                if (!this.map) return;
                this.currentLandmarkIndex = (this.currentLandmarkIndex + 1) % this.landmarks.length;
                const landmark = this.landmarks[this.currentLandmarkIndex];
                this.map.setView([landmark.lat, landmark.lng], 18, { animate: true, duration: 1.5 });
                debugLog(`Jump to: ${landmark.name}`);
            }

            detect_wave_gesture(landmarks) {
                const rightWrist = landmarks[16];
                const rightShoulder = landmarks[12];

                debugLog(`Wave detect: x=${rightWrist.x}, y=${rightWrist.y}`);
                return rightWrist.x > 0.7 && rightWrist.y < 0.4; // é™ä½é˜ˆå€¼
            }

            toggle_map_layer() {
                if (!this.map) return;
                const layers = Object.values(this.map._layers);
                const hasSatellite = layers.some(layer => layer._url?.includes('ArcGIS'));

                layers.forEach(layer => {
                    if (layer._url && (layer._url.includes('openstreetmap.org') || layer._url.includes('ArcGIS'))) {
                        this.map.removeLayer(layer);
                    }
                });

                if (hasSatellite) {
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(this.map);
                    debugLog('Switch to street map');
                } else {
                    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri' }).addTo(this.map);
                    debugLog('Switch to satellite map');
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            debugLog('DOM loaded. Initializing map...');

            map = L.map('map', {
                center: [48.8566, 2.3522],
                zoom: 16,
                layers: [L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' })]
            });

            debugLog('Map initialized. Initializing gesture controller...');
            gestureController = new OSMGestureController();
            gestureController.setMap(map);

            // Add markers for European landmarks
            gestureController.landmarks.forEach((landmark, index) => {
                const marker = L.marker([landmark.lat, landmark.lng]).addTo(map);
                marker.bindPopup(`<b>${landmark.name}</b>`);

                // Add click event to jump to landmark when marker is clicked
                marker.on('click', () => {
                    gestureController.currentLandmarkIndex = index;
                    gestureController.jump_to_next_landmark();
                });

                debugLog(`Added marker for: ${landmark.name}`);
            });

            document.getElementById('mapStatus').textContent = 'åœ°å›¾åŠ è½½å®Œæˆ';

            debugLog('Loading MediaPipe Pose...');
            let pose;

            try {
                pose = new Pose({
                    locateFile: (file) => {
                        const url = `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                        debugLog(`Loading MediaPipe file: ${url}`);
                        return url;
                    }
                });

                debugLog('MediaPipe Pose instance created successfully!');

                // æé«˜æ¨¡å‹å¤æ‚åº¦ä»¥æé«˜æ£€æµ‹ç²¾åº¦
                pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    minDetectionConfidence: 0.3, // é™ä½ç½®ä¿¡åº¦é˜ˆå€¼
                    minTrackingConfidence: 0.3  // é™ä½ç½®ä¿¡åº¦é˜ˆå€¼
                });

                    // ç”¨äºè·Ÿè¸ªæ‰‹è…•ä½ç½®ä»¥æ£€æµ‹æ»‘åŠ¨æ‰‹åŠ¿
            let previousRightWristX = null;
            let swipeThreshold = 0.2; // æ»‘åŠ¨æ£€æµ‹é˜ˆå€¼

            pose.onResults(results => {
                    const canvasCtx = document.getElementById('outputCanvas').getContext('2d');
                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, 320, 240);
                    canvasCtx.drawImage(results.image, 0, 0, 320, 240);

                    if (results.poseLandmarks) {
                        debugLog('Pose landmarks detected!');

                        // æ»‘åŠ¨æ‰‹åŠ¿æ£€æµ‹ - ä½¿ç”¨å³æ‰‹è…•ä½ç½®
                        const rightWrist = results.poseLandmarks[16];
                        const rightShoulder = results.poseLandmarks[12];

                        // åªåœ¨æ‰‹è‡‚æŠ¬èµ·æ—¶æ£€æµ‹æ»‘åŠ¨ (æ‰‹è…•åœ¨è‚©è†€ä¸Šæ–¹)
                        if (rightWrist.y < rightShoulder.y) {
                            if (previousRightWristX !== null) {
                                const deltaX = rightWrist.x - previousRightWristX;

                                // å·¦æ»‘åŠ¨æ£€æµ‹ (æ•°å€¼å‡å°)
                                if (deltaX < -swipeThreshold) {
                                    debugLog('Left swipe detected!');
                                    gestureController.jump_to_next_landmark();
                                }
                                // å³æ»‘åŠ¨æ£€æµ‹ (æ•°å€¼å¢å¤§)
                                else if (deltaX > swipeThreshold) {
                                    debugLog('Right swipe detected!');
                                    gestureController.currentLandmarkIndex = (gestureController.currentLandmarkIndex - 2 + gestureController.landmarks.length) % gestureController.landmarks.length;
                                    gestureController.jump_to_next_landmark();
                                }
                            }
                            // æ›´æ–°ä¸Šä¸€å¸§æ‰‹è…•ä½ç½®
                            previousRightWristX = rightWrist.x;
                        }
                        // å½“æ‰‹è‡‚æ”¾ä¸‹æ—¶ï¼Œé‡ç½®æ»‘åŠ¨è·Ÿè¸ª
                        else {
                            previousRightWristX = null;
                        }

                        // ç»˜åˆ¶å…³é”®ç‚¹
                        for (const [index, landmark] of results.poseLandmarks.entries()) {
                            canvasCtx.beginPath();
                            canvasCtx.arc(landmark.x * 320, landmark.y * 240, 3, 0, 2 * Math.PI);
                            canvasCtx.fillStyle = '#00FF00';
                            canvasCtx.fill();

                            // æ ‡è®°å…³é”®ç‚¹ç´¢å¼•
                            if (index === 11 || index === 12 || index === 13 || index === 14 || index === 15 || index === 16) {
                                canvasCtx.fillStyle = '#FF0000';
                                canvasCtx.font = '8px Arial';
                                canvasCtx.fillText(index, landmark.x * 320 + 4, landmark.y * 240 + 3);
                            }
                        }

                        // ç»˜åˆ¶è¿æ¥çº¿
                        const connections = [[11, 12], [11, 13], [13, 15], [12, 14], [14, 16], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28]];
                        canvasCtx.strokeStyle = '#00FF00';
                        canvasCtx.lineWidth = 2;
                        for (const [start, end] of connections) {
                            const startLandmark = results.poseLandmarks[start];
                            const endLandmark = results.poseLandmarks[end];
                            if (startLandmark && endLandmark) {
                                canvasCtx.beginPath();
                                canvasCtx.moveTo(startLandmark.x * 320, startLandmark.y * 240);
                                canvasCtx.lineTo(endLandmark.x * 320, endLandmark.y * 240);
                                canvasCtx.stroke();
                            }
                        }

                        // æ‰‹åŠ¿è¯†åˆ«æµç¨‹
                        let detectedGesture = null;

                        if (gestureController.detectPointingGesture(results.poseLandmarks)) {
                            const direction = gestureController.getPointingDirection(results.poseLandmarks);
                            gestureController.pan_map_toward_direction(direction);
                            detectedGesture = `æŒ‡å‘ ${direction}`;
                        } else if (gestureController.detect_spread_hands(results.poseLandmarks)) {
                            gestureController.zoom_in();
                            detectedGesture = "æ”¾å¤§";
                        } else if (gestureController.detect_pinch_hands(results.poseLandmarks)) {
                            gestureController.zoom_out();
                            detectedGesture = "ç¼©å°";
                        } else if (gestureController.detect_clap_gesture(results.poseLandmarks)) {
                            gestureController.jump_to_next_landmark();
                            detectedGesture = "è·³è½¬åœ°æ ‡";
                        } else if (gestureController.detect_wave_gesture(results.poseLandmarks)) {
                            gestureController.toggle_map_layer();
                            detectedGesture = "åˆ‡æ¢å›¾å±‚";
                        }

                        document.getElementById('currentGesture').textContent = detectedGesture || "æ— æ‰‹åŠ¿";

                    } else {
                        debugLog('No pose landmarks detected!');
                        document.getElementById('currentGesture').textContent = "æœªæ£€æµ‹åˆ°èº«ä½“å§¿æ€";
                    }

                    canvasCtx.restore();
                });

                pose.onError(error => {
                    debugLog('MediaPipe error: ' + JSON.stringify(error));
                });

            } catch (error) {
                debugLog('Error initializing MediaPipe Pose: ' + error.message);
                console.error('MediaPipe initialization error:', error);
            }

            async function startCamera() {
                debugLog('Starting camera...');

                const videoElement = document.getElementById('videoElement');

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 320, height: 240, frameRate: { ideal: 30 } }
                    });

                    videoElement.srcObject = stream;
                    videoElement.style.display = 'block';
                    debugLog('Camera stream obtained successfully.');

                    // ä½¿ç”¨MediaPipeçš„Cameraç±»å¤„ç†è§†é¢‘æµ
                    const camera = new Camera(videoElement, {
                        onFrame: async () => {
                            try {
                                await pose.send({ image: videoElement });
                            } catch (error) {
                                debugLog('Frame processing error: ' + error.message);
                            }
                        },
                        width: 320,
                        height: 240
                    });

                    camera.start();
                    document.getElementById('gestureStatus').textContent = 'æ‘„åƒå¤´å·²å¯åŠ¨ - æ­£åœ¨æ£€æµ‹æ‰‹åŠ¿';
                    document.getElementById('startCamera').textContent = 'æ‘„åƒå¤´å·²å¯åŠ¨';
                    document.getElementById('startCamera').disabled = true;

                    debugLog('Camera started successfully.');

                } catch (error) {
                    debugLog('Camera access error: ' + error.message);
                    alert('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: ' + error.message);
                    document.getElementById('gestureStatus').textContent = 'æ‘„åƒå¤´å¯åŠ¨å¤±è´¥';
                }
            }

            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            document.getElementById('startCamera').addEventListener('click', startCamera);

            document.getElementById('resetMap').addEventListener('click', () => {
                map.setView([48.8566, 2.3522], 16);
                debugLog('Map reset.');
            });

            document.getElementById('toggleLayer').addEventListener('click', () => {
                gestureController.toggle_map_layer();
            });

            debugLog('App initialized. Waiting for user action...');
        });
    </script>
</body>
</html>
