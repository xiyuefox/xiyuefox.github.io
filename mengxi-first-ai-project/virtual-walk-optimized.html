<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Walk - OSM ä¼˜åŒ–æ‰‹åŠ¿ç‰ˆ</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

    <style>
        /* åŸºç¡€æ ·å¼ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft Yahei', Arial, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        /* æ ‡é¢˜å’ŒçŠ¶æ€ */
        #header {
            background: rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        #header h1 {
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
            color: #2ecc71;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        #statusBar {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            margin: 0 20px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        /* æ¸¸æˆåŒºåŸŸ */
        #gameArea {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            padding: 0 20px;
            margin-bottom: 20px;
        }

        /* æ‘„åƒå¤´å’Œæ‰‹åŠ¿åŒºåŸŸ */
        #cameraSection {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        #videoElement, #outputCanvas {
            width: 100%;
            max-width: 320px;
            border-radius: 8px;
            display: block;
            margin: 0 auto 10px;
        }

        #currentGesture {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #actionLog {
            font-size: 14px;
            color: #fff;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px;
            border-radius: 5px;
        }

        /* åœ°å›¾åŒºåŸŸ */
        #mapSection {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        #map {
            height: 500px;
            border-radius: 8px;
        }

        /* æ§åˆ¶é¢æ¿ */
        #controlPanel {
            background: rgba(255, 255, 255, 0.1);
            padding: 1.2rem;
            margin: 0 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            min-width: 120px;
        }

        .camera-btn {
            background: rgba(46, 204, 113, 0.8);
        }

        .camera-btn:hover {
            background: rgba(46, 204, 113, 1);
            transform: translateY(-2px);
        }

        .map-btn {
            background: rgba(52, 152, 219, 0.8);
        }

        .map-btn:hover {
            background: rgba(52, 152, 219, 1);
            transform: translateY(-2px);
        }

        /* Leaflet æ ·å¼ä¿®å¤ */
        .leaflet-control-attribution {
            background: rgba(0, 0, 0, 0.6) !important;
            color: white !important;
            font-size: 10px !important;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            #gameArea {
                grid-template-columns: 1fr;
            }

            #statusBar {
                flex-direction: column;
                text-align: center;
            }

            #map {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>ğŸ–ï¸ Virtual Walk - OSM ä¼˜åŒ–æ‰‹åŠ¿ç‰ˆ</h1>
        <p>åŸºäº OpenStreetMap çš„ä¼˜åŒ–æ‰‹åŠ¿äº¤äº’è®¾è®¡</p>
    </div>

    <div id="statusBar">
        <div id="gestureStatus">ç­‰å¾…å¯åŠ¨æ‘„åƒå¤´...</div>
        <div id="mapStatus">åœ°å›¾åŠ è½½ä¸­...</div>
    </div>

    <div id="gameArea">
        <!-- æ‘„åƒå¤´å’Œæ‰‹åŠ¿åŒºåŸŸ -->
        <div id="cameraSection">
            <video id="videoElement" width="320" height="240" autoplay muted playsinline style="display: none;"></video>
            <canvas id="outputCanvas" width="320" height="240"></canvas>
            <div id="currentGesture">æ— æ‰‹åŠ¿</div>
            <div id="actionLog">ç­‰å¾…æ‰‹åŠ¿è¾“å…¥...</div>
        </div>

        <!-- åœ°å›¾åŒºåŸŸ -->
        <div id="mapSection">
            <div id="map"></div>
        </div>
    </div>

    <div id="controlPanel">
        <button class="control-btn camera-btn" id="startCamera">å¯åŠ¨æ‘„åƒå¤´</button>
        <button class="control-btn map-btn" id="resetMap">é‡ç½®åœ°å›¾</button>
        <button class="control-btn map-btn" id="toggleLayer">åˆ‡æ¢å›¾å±‚</button>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- MediaPipe Pose ä¾èµ– -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

    <script>
        // --------------------------
        // OSM ä¼˜åŒ–æ‰‹åŠ¿æ§åˆ¶å™¨
        // --------------------------
        class OSMGestureController {
            constructor() {
                this.interaction_mode = "exploration";
                this.map = null;
                this.currentZoom = 16;
                this.landmarks = [
                    { lat: 48.8566, lng: 2.3522, name: "å·´é»åŸƒè²å°”é“å¡”" },
                    { lat: 35.6895, lng: 139.6917, name: "ä¸œäº¬å¡”" },
                    { lat: 39.9042, lng: 116.4074, name: "åŒ—äº¬å¤©å®‰é—¨" },
                    { lat: 31.2304, lng: 121.4737, name: "ä¸Šæµ·å¤–æ»©" }
                ];
                this.currentLandmarkIndex = 0;
            }

            setMap(map) {
                this.map = map;
            }

            detectPointingGesture(landmarks) {
                const rightWrist = landmarks[16];
                const rightShoulder = landmarks[12];
                const rightElbow = landmarks[14];

                // æ£€æµ‹å³è‡‚æ˜¯å¦ä¼¸ç›´
                const armStraight = Math.abs(rightWrist.y - rightShoulder.y) > 0.15 &&
                                   Math.abs(rightElbow.y - (rightShoulder.y + rightWrist.y) / 2) < 0.05;

                return armStraight;
            }

            getPointingDirection(landmarks) {
                const rightWrist = landmarks[16];
                const rightShoulder = landmarks[12];

                // è®¡ç®—æŒ‡å‘æ–¹å‘ (0-360åº¦)
                const deltaX = rightWrist.x - rightShoulder.x;
                const deltaY = rightWrist.y - rightShoulder.y;

                // ç®€åŒ–ä¸ºå››ä¸ªæ–¹å‘
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    return deltaX > 0 ? "right" : "left";
                } else {
                    return deltaY > 0 ? "down" : "up";
                }
            }

            pan_map_toward_direction(direction) {
                if (!this.map) return;

                const currentCenter = this.map.getCenter();
                const moveDistance = 0.001;

                let newLat = currentCenter.lat;
                let newLng = currentCenter.lng;

                switch (direction) {
                    case "up": newLat += moveDistance; break;
                    case "down": newLat -= moveDistance; break;
                    case "left": newLng -= moveDistance; break;
                    case "right": newLng += moveDistance; break;
                }

                this.map.setView([newLat, newLng], this.currentZoom, { animate: true, duration: 0.5 });
                this.logAction("åœ°å›¾å‘ " + direction + " å¹³ç§»");
            }

            detect_spread_hands(landmarks) {
                const leftWrist = landmarks[15];
                const rightWrist = landmarks[16];

                // æ£€æµ‹åŒæ‰‹è·ç¦»
                const distance = Math.sqrt(Math.pow(rightWrist.x - leftWrist.x, 2) + Math.pow(rightWrist.y - leftWrist.y, 2));

                return distance > 0.4; // è·ç¦»é˜ˆå€¼
            }

            detect_pinch_hands(landmarks) {
                const leftWrist = landmarks[15];
                const rightWrist = landmarks[16];

                // æ£€æµ‹åŒæ‰‹è·ç¦»
                const distance = Math.sqrt(Math.pow(rightWrist.x - leftWrist.x, 2) + Math.pow(rightWrist.y - leftWrist.y, 2));

                return distance < 0.2; // è·ç¦»é˜ˆå€¼
            }

            zoom_in() {
                if (!this.map) return;

                this.currentZoom = Math.min(19, this.currentZoom + 1);
                this.map.setZoom(this.currentZoom);
                this.logAction("åœ°å›¾æ”¾å¤§");
            }

            zoom_out() {
                if (!this.map) return;

                this.currentZoom = Math.max(8, this.currentZoom - 1);
                this.map.setZoom(this.currentZoom);
                this.logAction("åœ°å›¾ç¼©å°");
            }

            detect_clap_gesture(landmarks) {
                // ç®€å•çš„æ‹æ‰‹æ£€æµ‹ï¼šåŒæ‰‹è…•åœ¨èº«ä½“ä¸­å¿ƒé™„è¿‘ä¸”è·ç¦»å¾ˆè¿‘
                const leftWrist = landmarks[15];
                const rightWrist = landmarks[16];

                const distance = Math.sqrt(Math.pow(rightWrist.x - leftWrist.x, 2) + Math.pow(rightWrist.y - leftWrist.y, 2));

                // åŒæ‰‹åœ¨èº«ä½“ä¸­å¿ƒåŒºåŸŸä¸”è·ç¦»å¾ˆè¿‘
                return distance < 0.15 &&
                       Math.abs(leftWrist.x - 0.5) < 0.1 &&
                       Math.abs(rightWrist.x - 0.5) < 0.1;
            }

            jump_to_next_landmark() {
                if (!this.map) return;

                this.currentLandmarkIndex = (this.currentLandmarkIndex + 1) % this.landmarks.length;
                const landmark = this.landmarks[this.currentLandmarkIndex];

                this.map.setView([landmark.lat, landmark.lng], 18, { animate: true, duration: 1.5 });
                this.logAction("è·³è½¬åˆ°: " + landmark.name);
            }

            detect_wave_gesture(landmarks) {
                // ç®€å•çš„æŒ¥æ‰‹æ£€æµ‹ï¼šå³æ‰‹å¿«é€Ÿä¸Šä¸‹ç§»åŠ¨
                // è¿™é‡Œç®€åŒ–å¤„ç†ä¸ºæ£€æµ‹å³æ‰‹è…•ä½ç½®å˜åŒ–

                // æ£€æµ‹å³è‡‚æ˜¯å¦åœ¨èº«ä½“å³ä¾§æŒ¥åŠ¨
                const rightWrist = landmarks[16];
                const rightShoulder = landmarks[12];

                // å³æ‰‹åœ¨èº«ä½“å³ä¾§ä¸”é«˜äºè‚©è†€
                return rightWrist.x > rightShoulder.x + 0.15 && rightWrist.y < rightShoulder.y - 0.1;
            }

            toggle_map_layer() {
                if (!this.map) return;

                const currentLayer = this.map._layers;
                const hasSatellite = Object.values(currentLayer).some(layer => layer._url && layer._url.includes('ArcGIS'));

                // åˆ‡æ¢å›¾å±‚
                if (hasSatellite) {
                    // åˆ‡æ¢åˆ°è¡—é“å›¾
                    this.map.eachLayer(layer => {
                        if (layer._url && layer._url.includes('ArcGIS')) {
                            this.map.removeLayer(layer);
                        }
                    });
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; OpenStreetMap contributors'
                    }).addTo(this.map);
                    this.logAction("åˆ‡æ¢åˆ°è¡—é“å›¾");
                } else {
                    // åˆ‡æ¢åˆ°å«æ˜Ÿå›¾
                    this.map.eachLayer(layer => {
                        if (layer._url && layer._url.includes('openstreetmap.org')) {
                            this.map.removeLayer(layer);
                        }
                    });
                    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        attribution: 'Tiles &copy; Esri'
                    }).addTo(this.map);
                    this.logAction("åˆ‡æ¢åˆ°å«æ˜Ÿå›¾");
                }
            }

            logAction(action) {
                document.getElementById('actionLog').textContent = "åŠ¨ä½œ: " + action;
            }
        }

        // --------------------------
        // åº”ç”¨å¯åŠ¨
        // --------------------------
        let gestureController;

        document.addEventListener('DOMContentLoaded', () => {
            // åˆå§‹åŒ–åœ°å›¾
            const map = L.map('map', {
                center: [48.8566, 2.3522],
                zoom: 16,
                layers: [
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; OpenStreetMap contributors'
                    })
                ]
            });

            // åˆå§‹åŒ–æ‰‹åŠ¿æ§åˆ¶å™¨
            gestureController = new OSMGestureController();
            gestureController.setMap(map);

            // åœ°å›¾åˆå§‹åŒ–å®Œæˆ
            document.getElementById('mapStatus').textContent = 'åœ°å›¾åŠ è½½å®Œæˆ';

            // åˆå§‹åŒ–MediaPipe Pose
            const pose = new Pose({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                }
            });

            pose.setOptions({
                modelComplexity: 0,
                smoothLandmarks: true,
                enableSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            // å§¿æ€ç»“æœå¤„ç†
            pose.onResults(results => {
                const canvasCtx = document.getElementById('outputCanvas').getContext('2d');

                // æ¸…ç©ºç”»å¸ƒå¹¶ç»˜åˆ¶è§†é¢‘å¸§
                canvasCtx.save();
                canvasCtx.clearRect(0, 0, 320, 240);
                canvasCtx.drawImage(results.image, 0, 0, 320, 240);

                // ç»˜åˆ¶å§¿æ€éª¨æ¶
                if (results.poseLandmarks) {
                    // ç»˜åˆ¶å…³é”®ç‚¹
                    for (const landmark of results.poseLandmarks) {
                        canvasCtx.beginPath();
                        canvasCtx.arc(landmark.x * 320, landmark.y * 240, 3, 0, 2 * Math.PI);
                        canvasCtx.fillStyle = '#00FF00';
                        canvasCtx.fill();
                    }

                    // ç»˜åˆ¶è¿æ¥çº¿
                    const connections = [
                        [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], [11, 23], [12, 24],
                        [23, 24], [23, 25], [24, 26], [25, 27], [26, 28]
                    ];
                    canvasCtx.strokeStyle = '#00FF00';
                    canvasCtx.lineWidth = 2;
                    for (const [start, end] of connections) {
                        const startLandmark = results.poseLandmarks[start];
                        const endLandmark = results.poseLandmarks[end];
                        if (startLandmark && endLandmark) {
                            canvasCtx.beginPath();
                            canvasCtx.moveTo(startLandmark.x * 320, startLandmark.y * 240);
                            canvasCtx.lineTo(endLandmark.x * 320, endLandmark.y * 240);
                            canvasCtx.stroke();
                        }
                    }

                    // æ‰‹åŠ¿è¯†åˆ«ä¸åŠ¨ä½œæ˜ å°„
                    let detectedGesture = null;

                    // æ£€æµ‹å¹¶æ‰§è¡Œæ‰‹åŠ¿
                    if (gestureController.detectPointingGesture(results.poseLandmarks)) {
                        const direction = gestureController.getPointingDirection(results.poseLandmarks);
                        gestureController.pan_map_toward_direction(direction);
                        detectedGesture = "æŒ‡å‘ " + direction;
                    } else if (gestureController.detect_spread_hands(results.poseLandmarks)) {
                        gestureController.zoom_in();
                        detectedGesture = "å¼ å¼€åŒæ‰‹";
                    } else if (gestureController.detect_pinch_hands(results.poseLandmarks)) {
                        gestureController.zoom_out();
                        detectedGesture = "åˆæ‹¢åŒæ‰‹";
                    } else if (gestureController.detect_clap_gesture(results.poseLandmarks)) {
                        gestureController.jump_to_next_landmark();
                        detectedGesture = "æ‹æ‰‹";
                    } else if (gestureController.detect_wave_gesture(results.poseLandmarks)) {
                        gestureController.toggle_map_layer();
                        detectedGesture = "æŒ¥æ‰‹";
                    }

                    // æ›´æ–°å½“å‰æ‰‹åŠ¿æ˜¾ç¤º
                    document.getElementById('currentGesture').textContent = detectedGesture || "æ— æ‰‹åŠ¿";
                }

                canvasCtx.restore();
            });

            // å¯åŠ¨æ‘„åƒå¤´
            async function startCamera() {
                const videoElement = document.getElementById('videoElement');

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 320, height: 240 }
                    });
                    videoElement.srcObject = stream;
                    videoElement.style.display = 'block';

                    // ä½¿ç”¨MediaPipeçš„Cameraç±»å¤„ç†è§†é¢‘æµ
                    const camera = new Camera(videoElement, {
                        onFrame: async () => {
                            await pose.send({ image: videoElement });
                        },
                        width: 320,
                        height: 240
                    });

                    camera.start();
                    document.getElementById('gestureStatus').textContent = 'æ‘„åƒå¤´å·²å¯åŠ¨ - æ­£åœ¨æ£€æµ‹æ‰‹åŠ¿';
                    document.getElementById('startCamera').textContent = 'æ‘„åƒå¤´å·²å¯åŠ¨';
                    document.getElementById('startCamera').disabled = true;
                } catch (error) {
                    console.error('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:', error);
                    alert('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: ' + error.message);
                    document.getElementById('gestureStatus').textContent = 'æ‘„åƒå¤´å¯åŠ¨å¤±è´¥';
                }
            }

            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            document.getElementById('startCamera').addEventListener('click', startCamera);

            document.getElementById('resetMap').addEventListener('click', () => {
                map.setView([48.8566, 2.3522], 16);
                gestureController.logAction("åœ°å›¾å·²é‡ç½®");
            });

            document.getElementById('toggleLayer').addEventListener('click', () => {
                gestureController.toggle_map_layer();
            });
        });
    </script>
</body>
</html>